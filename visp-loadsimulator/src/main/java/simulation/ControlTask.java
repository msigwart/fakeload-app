package simulation;

import common.enums.SimulationScope;
import common.enums.SimulationType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.management.ManagementFactory;
import com.sun.management.OperatingSystemMXBean;

import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryManagerMXBean;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;

import static common.enums.SimulationType.*;
import static simulation.LoadControlObject.AdjustmentType.DECREASE;
import static simulation.LoadControlObject.AdjustmentType.INCREASE;

/**
 * This class acts as the controlling entity of the load simulation. Whenever a load simulation is run, this class is run
 * as a separate thread to monitor the actual load generated by the simulator threads. Whenever a significant deviation
 * between desired and actual load is detected, the class adjusts the load slightly in the direction of target. This way
 * the load generated by the simulation actually reaches the desired level.
 *
 * Created by martensigwart on 13.06.17.
 */
public class ControlTask implements Callable<String> {

    public static final long CONTROL_TASK_PERIOD_SLEEP = 2000;
    public static final long CONTROL_TASK_INITIAL_SLEEP = 10000;

    private static final Logger log = LoggerFactory.getLogger(ControlTask.class);
    private static final OperatingSystemMXBean operatingSystem = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
    private static final MemoryMXBean memory = (MemoryMXBean) ManagementFactory.getMemoryMXBean();
    private static final double RELATIVE_MARGIN = 0.01;

    private Map<SimulationType, LoadControlObject> loadParameters;     //the desired system loads
    private SimulationScope scope;
    private Integer noCores;


    public ControlTask(SimulationScope scope, Integer noCores) {
        this.loadParameters = new HashMap<>();
        this.scope = scope;
        this.noCores = noCores;
    }

    @Override
    public String call() throws Exception {
        log.info("Control Task started");

        Thread.sleep(CONTROL_TASK_INITIAL_SLEEP);

        while (true) {
            Thread.sleep(CONTROL_TASK_PERIOD_SLEEP);

            // Control CPU Load
            controlCpuLoad();

            // Control RAM Load
            controlRamLoad();

        }

    }

    private void controlRamLoad() {
        LoadControlObject controlObject = loadParameters.get(RAM);
        Integer desiredLoad = controlObject.getInitialWorkload();
        Double actualLoad;


        switch (scope) {

            case SYSTEM:
                break;
            case PROCESS:
                break;
        }
    }


    public LoadControlObject getLoad(SimulationType type) {
        return this.loadParameters.get(type);
    }


    public Boolean containsCpu() {
        return loadParameters.containsKey(CPU);
    }

    public Boolean containsRam() {
        return loadParameters.containsKey(RAM);
    }


    public void setInitialLoad(SimulationType type, Integer initialLoad, Integer method) {
        this.loadParameters.put(type, new LoadControlObject(type, initialLoad, method));
    }


    private void controlCpuLoad() {
        Integer desiredLoad = loadParameters.get(CPU).getInitialWorkload();
        Double actualLoad;

        switch (scope) {
            case PROCESS:
                actualLoad = operatingSystem.getProcessCpuLoad() * 100;
                break;
            case SYSTEM:
            default:
                actualLoad = operatingSystem.getSystemCpuLoad() * 100;
                break;
        }

        log.debug("Desired: {}, Actual: {}", desiredLoad, actualLoad);

        // Define differences to ignore
        if (actualLoad <= 0.0) return;
        if (Math.abs(actualLoad - desiredLoad) > 10.0) return;

        // Calculate adjustment of CPU load
        Double stepSize = 1.0 / noCores;
        Double loadDifference = actualLoad - desiredLoad;

        Integer noOfSteps = Math.abs(new Double(loadDifference / stepSize).intValue());

        LoadControlObject.AdjustmentType type = (loadDifference > 0 ? DECREASE : INCREASE);
        this.loadParameters.get(CPU).setAdjustment(noOfSteps, type);
    }


}

